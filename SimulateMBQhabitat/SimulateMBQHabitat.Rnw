\documentclass{article}
\title{Testing MBQ Model Discrepancy on Simulated Landscape Data}
\author{Dominic LaRoche}
\begin{document}
It might be useful to generate a finer W matrix to avoid large areas of extreme values generated by the interpolation of sparse points
<<makedatagrid>
require(reshape)


require(spdep)
rho<-0.95
N<-200
x.coord<-runif(N,0,100)
y.coord<-runif(N,0,100)
points<-cbind(x.coord,y.coord)
rm(x.coord,y.coord)
e<-rbeta(N,2,3)
dnb<-dnearneigh(points,0,150) #neighbourhood contiguity by distance
dsts<-nbdists(dnb,points) #spatial link distance measures
idw<-lapply(dsts,function(x) 1/x) #inverse of distance measures
lw<-nb2listw(dnb,glist=idw,style="W")
inv<-invIrW(lw,rho)
GC<-inv%*%e
GC2<-GC-min(GC)
sim1<-cbind(points,GC2)
sim1<-as.data.frame(sim1)
names(sim1)<-c("x","y","GC")
require(akima)
simR<-with(sim1,interp(x,y,GC,xo=seq(0,100,length=100),yo=seq(0,100,length=100),duplicate="mean"))#make regular grid of values
require(ggplot2)
require(reshape)
sim.m<-melt(simR[3])
names(sim.m)<-c("x","y","GC")
gcp<-ggplot(sim.m,aes(x=x,y=y,z=GC))

gcp+stat_contour()


<<MakeBetaLayer>>=
make.beta.layer<-function(rho,N,numpoints1,numpoints2,beta1,beta2,dist){
  require(spdep)
  require(akima)
  require(ggplot2)
  require(reshape)
  x.coord<-runif(N,numpoints1,numpoints2)
  y.coord<-runif(N,numpoints1,numpoints2)
  points<-cbind(x.coord,y.coord)
  e<-rbeta(N,beta1,beta2)
  dnb<-dnearneigh(points,0,dist) #neighbourhood contiguity by distance
  dsts<-nbdists(dnb,points) #spatial link distance measures
  idw<-lapply(dsts,function(x) 1/x) #inverse of distance measures
  lw<-nb2listw(dnb,glist=idw,style="W")
  inv<-invIrW(lw,rho)
  y<-inv%*%e
  y2<-y-min(y)
  d<-cbind(points,y2)
  df<-as.data.frame(d)
  names(df)<-c("x","y","GC")
  df.grid<-with(df,interp(x,y,GC,xo=seq(0,100,length=100),yo=seq(0,100,length=100),duplicate="mean",linear=FALSE,extrap=TRUE))#make regular grid of values
  df.grid.bounded<-pmax(pmin(df.grid[[3]],1),0)#censor interpolated values within beta distribution
  df.m<-melt(df.grid.bounded)
  names(df.m)<-c("x","y","GC")
  p<-ggplot(df.m,aes(x=x,y=y,z=GC))
  cp<-p+stat_contour()
  return(list(df.m,cp))
}
@
<<MakeNormLayer>>=
make.norm.layer<-function(rho,N,numpoints1,numpoints2,norm1,norm2,lower,upper,dist){
  require(spdep)
  require(akima)
  require(ggplot2)
  require(reshape)
  x.coord<-runif(N,numpoints1,numpoints2)
  y.coord<-runif(N,numpoints1,numpoints2)
  points<-cbind(x.coord,y.coord)
  e<-rnorm(N,norm1,norm2)
  dnb<-dnearneigh(points,0,dist) #neighbourhood contiguity by distance
  dsts<-nbdists(dnb,points) #spatial link distance measures
  idw<-lapply(dsts,function(x) 1/x) #inverse of distance measures
  lw<-nb2listw(dnb,glist=idw,style="W")
  inv<-invIrW(lw,rho)
  y<-inv%*%e
  y2<-y-min(y)
  d<-cbind(points,y2)
  df<-as.data.frame(d)
  names(df)<-c("x","y","GC")
  df.grid<-with(df,interp(x,y,GC,xo=seq(0,100,length=100),yo=seq(0,100,length=100),duplicate="mean",linear=FALSE,extrap=TRUE))#make regular grid of values
  df.grid.bounded<-pmax(pmin(df.grid[[3]],upper),lower)#censor interpolated values within given distribution
  df.m<-melt(df.grid.bounded)
  names(df.m)<-c("x","y","GC")
  p<-ggplot(df.m,aes(x=x,y=y,z=GC))
  cp<-p+stat_contour()
  return(list(df.m,cp))
}
@
<<MakeGammaLayer>>=
make.gamma.layer<-function(rho,N,numpoints1,numpoints2,gamma1,gamma2,lower,upper,dist){
  require(spdep)
  require(akima)
  require(ggplot2)
  require(reshape)
  x.coord<-runif(N,numpoints1,numpoints2)
  y.coord<-runif(N,numpoints1,numpoints2)
  points<-cbind(x.coord,y.coord)
  e<-rgamma(N,gamma1,gamma2)
  dnb<-dnearneigh(points,0,dist) #neighbourhood contiguity by distance
  dsts<-nbdists(dnb,points) #spatial link distance measures
  idw<-lapply(dsts,function(x) 1/x) #inverse of distance measures
  lw<-nb2listw(dnb,glist=idw,style="W")
  inv<-invIrW(lw,rho)
  y<-inv%*%e
  y2<-y-min(y)
  d<-cbind(points,y2)
  df<-as.data.frame(d)
  names(df)<-c("x","y","GC")
  df.grid<-with(df,interp(x,y,GC,xo=seq(0,100,length=100),yo=seq(0,100,length=100),duplicate="mean",linear=FALSE,extrap=TRUE))#make regular grid of values
  df.grid.bounded<-pmax(pmin(df.grid[[3]],upper),lower)#censor interpolated values within given distribution
  df.m<-melt(df.grid.bounded)
  names(df.m)<-c("x","y","GC")
  p<-ggplot(df.m,aes(x=x,y=y,z=GC))
  cp<-p+stat_contour()
  return(list(df.m,cp))
}
@
For all of the following simulations I set the highest probability for each value to be the highest suitability level (or close if there are discrepencies between models).  Results from this entire exercise will likely differ if these values are changed and it would probably be a good idea to see how models perform when ideal conditions are less proabable or even absent.\\ 
<<SimulateGrassCover>>=
set.seed(rpois(1,200))
gc1<-make.beta.layer(.95,200,0,100,2,3,50)
p<-gc1[[2]]
p+stat_contour(aes(colour=..level..),binwidth=.1)
gcdf<-gc1[[1]]
@
<<simulateTreeCover>>=
tc1<-make.beta.layer(.99,200,0,100,10,190,25)
tcp<-tc1[[2]]
tcp+stat_contour(aes(colour=..level..),binwidth=.01)
tcdf<-tc1[[1]]
tcdf<-rename(tcdf,c(GC="TC"))
@
<<simulateForbCover>>=
fc1<-make.beta.layer(.95,200,0,100,4,4,50)
fcp<-fc1[[2]]
fcp+stat_contour(aes(colour=..level..),binwidth=.1)
fcdf<-fc1[[1]]
fcdf<-rename(fcdf,c(GC="FC"))
@
<<simulateShrubCover>>=
sc1<-make.beta.layer(.95,200,0,100,5,20,35)
scp<-sc1[[2]]
scp+stat_contour(aes(colour=..level..),binwidth=.1)
scdf<-sc1[[1]]
scdf<-rename(scdf,c(GC="SC"))
@
<<simulateBareGround>>=
bg1<-make.beta.layer(.95,200,0,100,3,9,75)
bgp<-bg1[[2]]
bgp+stat_contour(aes(colour=..level..),binwidth=.1)
bgdf<-bg1[[1]]
bgdf<-rename(bgdf,c(GC="BG"))
@
<<simulateGrassDiversity>>=
gd1<-make.gamma.layer(.95,200,0,100,7,.7,1,40,50)
gdp<-gd1[[2]]
gdp+stat_contour(aes(colour=..level..),binwidth=2)
gddf<-gd1[[1]]
gddf<-rename(gddf,c(GC="GD"))
@
<<simulateForbDiversity>>=
fd1<-make.gamma.layer(.95,200,0,100,5,.6,1,40,100)
fdp<-fd1[[2]]
fdp+stat_contour(aes(colour=..level..),binwidth=2)
fddf<-fd1[[1]]
fddf<-rename(fddf,c(GC="FD"))
@
<<simulateShrubDiversity>>=
sd1<-make.gamma.layer(.95,200,0,100,4,.9,1,30,50)
sdp<-sd1[[2]]
sdp+stat_contour(aes(colour=..level..),binwidth=2)
sddf<-sd1[[1]]
sddf<-rename(sddf,c(GC="SD"))
@
<<simulateForbHeight>>=
fh1<-make.gamma.layer(.95,200,0,100,3,.06,1,200,50)
fhp<-fh1[[2]]
fhp+stat_contour(aes(colour=..level..),binwidth=10)
fhdf<-fh1[[1]]
fhdf<-rename(fhdf,c(GC="FH"))
@
<<simulateShrubHeight>>=
sh1<-make.gamma.layer(.95,400,0,100,9,3.5,.1,15,50)
shp<-sh1[[2]]
shp+stat_contour(aes(colour=..level..),binwidth=.5)
shdf<-sh1[[1]]
shdf<-rename(shdf,c(GC="SH"))
@
<<simulateGrassHeightforcover>>=
ghc1<-make.gamma.layer(.95,400,0,100,2,4,.1,3,50)
ghcp<-ghc1[[2]]
ghcp+stat_contour(aes(colour=..level..),binwidth=.5)
ghcdf<-ghc1[[1]]
ghcdf<-rename(ghcdf,c(GC="GHc"))
@
<<SimulateGrassHopperAbundance>>=
gr1<-make.gamma.layer(.97,400,0,100,15,1,0,50,50)
grp<-gr1[[2]]
grp+stat_contour(aes(colour=..level..),binwidth=1)
grdf<-gr1[[1]]
grdf<-rename(grdf,c(GC="GR"))
@
<<SimulateNestSiteAbundance>>=
nc1<-make.norm.layer(.99,400,0,100,600,300,0,1300,50)
ncp<-nc1[[2]]
ncp+stat_contour(aes(colour=..level..),binwidth=100)
ncdf<-nc1[[1]]
ncdf<-rename(ncdf,c(GC="NC"))
@
<<SimulatePerennialGrassCover>>=
gcp1<-make.beta.layer(.95,400,0,100,5,4.09,50)
gcpp<-gcp1[[2]]
gcpp+stat_contour(aes(colour=..level..),binwidth=.1)
gcpdf<-gcp1[[1]]
gcpdf<-rename(gcpdf,c(GC="GCp"))
@
<<SimulateAnnualGrassCover>>=
gca1<-make.beta.layer(.95,400,0,100,2,3,50)
gcap<-gca1[[2]]
gcap+stat_contour(aes(colour=..level..),binwidth=.1)
gcadf<-gca1[[1]]
gcadf<-rename(gcadf,c(GC="GCa"))
@
<<SimulatePerennialGrassDiversity>>=
gdp1<-make.gamma.layer(.95,400,0,100,3,.9,1,10,50)
gdpp<-gdp1[[2]]
gdpp+stat_contour(aes(colour=..level..),binwidth=1)
gdpdf<-gdp1[[1]]
gdpdf<-rename(gdpdf,c(GC="GDp"))
@
<<SimulateAnnualGrassdiversity>>=
gda1<-make.gamma.layer(.95,400,0,100,2,.9,1,10,50)
gdap<-gda1[[2]]
gdap+stat_contour(aes(colour=..level..),binwidth=1)
gdadf<-gda1[[1]]
gdadf<-rename(gdadf,c(GC="GDa"))
@
<<simulateSpringForbHeight>>=
fhs<-make.gamma.layer(.95,400,0,100,4,.8,0,30,50)
fhsp<-fhs[[2]]
fhsp+stat_contour(aes(colour=..level..),binwidth=1)
fhsdf<-fhs[[1]]
fhsdf<-rename(fhsdf,c(GC="FHs"))
@
<<simulatefallForbHeight>>=
fhf<-make.gamma.layer(.95,400,0,100,20,1,0,30,50)
fhfp<-fhf[[2]]
fhfp+stat_contour(aes(colour=..level..),binwidth=1)
fhfdf<-fhf[[1]]
fhfdf<-rename(fhfdf,c(GC="FHf"))
@
<<simulateTreeCoverinArroyo>>=
tca<-make.norm.layer(.99,400,0,100,.1,.1,0,1,50)
tcap<-tca[[2]]
tcap+stat_contour(aes(colour=..level..),binwidth=.1)
tcadf<-tca[[1]]
tcadf<-rename(tcadf,c(GC="TCa"))
@
<<simulateSpringForbCover>>=
fcs<-make.beta.layer(.95,400,0,100,4,4,50)
fcsp<-fcs[[2]]
fcsp+stat_contour(aes(colour=..level..),binwidth=.1)
fcsdf<-fcs[[1]]
fcsdf<-rename(fcsdf,c(GC="FCs"))
@
<<simulateGrassCoverforVisObstruction>>=
gcv<-make.gamma.layer(.95,400,0,100,2.5,.4,0,25,50)#probably need to correlate this with grass canopy cover to be realistic with the final models
gcvp<-gcv[[2]]
gcvp+stat_contour(aes(colour=..level..),binwidth=1)
gcvdf<-gcv[[1]]
gcvdf<-rename(gcvdf,c(GC="GCv"))
@
<<simulateGrassBasalArea>>=
gcb<-make.beta.layer(.95,400,0,100,5,20,50)#should be correlated with visual obstruction
gcbp<-gcb[[2]]
gcbp+stat_contour(aes(colour=..level..),binwidth=.1)
gcbdf<-gcb[[1]]
gcbdf<-rename(gcbdf,c(GC="GCb"))
@
<<SimulateHalfshrubcover>>=
hsc<-make.beta.layer(.95,400,0,100,.1,10,50)
hscp<-hsc[[2]]
hscp+stat_contour(aes(colour=..level..),binwidth=.1)
hscdf<-hsc[[1]]
hscdf<-rename(hscdf,c(GC="HSC"))
@
<<combineLayers>>=
sim1<-merge(bgdf,fcdf)
rm(bgdf,fcdf,bg,fc)
sim1<-merge(sim1,fddf)
rm(fddf,fd)
sim1<-merge(sim1,fhdf)
rm(fhdf,fh)
sim1<-merge(sim1,gcdf)
rm(gcdf,gc)
sim1<-merge(sim1,gddf)
rm(gddf,gd)
sim1<-merge(sim1,ghcdf)
rm(ghcdf,ghc)
sim1<-merge(sim1,scdf)
rm(scdf)
sim1<-merge(sim1,sddf)
rm(sddf)
sim1<-merge(sim1,shdf)
rm(shdf,sh)
sim1<-merge(sim1,tcdf)
rm(tcdf,tc)
sim1<-merge(sim1,grdf)
rm(grdf,gr)
sim1<-merge(sim1,ncdf)
rm(ncdf,nc)
sim1<-merge(sim1,gcpdf)
rm(gcpdf,gcp)
sim1<-merge(sim1,gcadf)
rm(gcadf,gca)
sim1<-merge(sim1,gdpdf)
rm(gdpdf,gdp)
sim1<-merge(sim1,gdadf)
rm(gdadf,gda)
sim1<-merge(sim1,fhsdf)
rm(fhsdf,fhs)
sim1<-merge(sim1,fhfdf)
rm(fhfdf,fhf)
sim1<-merge(sim1,tcadf)
rm(tcadf,tca)
sim1<-merge(sim1,fcsdf)
rm(fcsdf,fcs)
sim1<-merge(sim1,gcvdf)
rm(gcvdf,gcv)
sim1<-merge(sim1,gcbdf)
rm(gcbdf,gcb)
sim1<-merge(sim1,hscdf)
rm(hscdf,hsc)
gc()
@
<<simulateStructuralDiversity>>=
#This variable represents Ellis' version of structural diversity
countif<-function(x){##Make a count if function to calculate structural diversity
  y<-rep(0,length(x))#empty shell
  for(i in 1:length(x)){
  y[i]<-ifelse(x[i]>.1,y[i]<-1,y[i]<-0)#classify as 1 if variable is greater than 10% cover and 0 otherwise
  }
  sumy<-sum(y)#add up cover variabes which meet threshold criteria
  return(sumy)
}
sim1$StrD<-rep(0,length(sim1[,1]))#create new variable shell
for(i in 1:length(sim1[,1])){#loop through each row
  sim1$StrD[i]<-countif(sim1[i,c(3,4,7,10,13)])
}

@
<<SimulateTotalCover>>=
for(i in 1:length(sim1$x)){
  sim1$TotalC<-with(sim1,(((GC+GCv+GCb)/3)*SC)^.5)
}
@
<<writeSimulationToFile>>=
require(MASS)
write.matrix(sim1,file="C:\\Users\\dominic\\Documents\\Work\\Current Projects\\MBQ\\SimulateMBQhabitat\\sim3.csv",sep=",")
@
\end{document}